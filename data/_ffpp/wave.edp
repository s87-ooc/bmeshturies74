/*************************************************************

 Projet

 (C) 2013 Charles Podkanski (charles@podkanski.com),
          Stjepan Stamenkovic (stjepan@stjepan.net)

 ---

     Fichier: wave.edp

 Description: vérification de la implémentation en utilisant FreeFem++

**************************************************************/

bool debug=true;

// ---

// problem parameters

real kappa = 10.;
real kx = 1. / sqrt(2.);
real ky = 1. / sqrt(2.);

real T = 2.25;
real dt = 0.05;
real nSteps = T / dt;

// ---

// defining the boundary
border C(t=0, 2*pi) {x=cos(t); y=sin(t);}

// ---

int grid = 50;

// domain is on the left side when following the boundary according to parametrization
mesh Th = buildmesh(C(grid));
savemesh(Th, "cercle_ffpp.msh");

plot(Th,wait=debug);

// space over Th with P1 elements
fespace Vh(Th, P1);

// initial values
Vh u0 = exp(-1. * ((x - 0.1)^2 + (y - 0.1)^2) / 0.01);
Vh u1 = 0.;

//func f = 0;
//func g = 0;

// ---

// TODO: assemble these matrices more efficiently

// uMatU = (M - (A + B)dt^2/2)
varf funcUmatU(u,v) = int2d(Th)(u*v)
						- int2d(Th)(dt^2/2 * (dx(u)*dx(v) + dy(u)*dy(v)))
						- int1d(Th, 1)(dt^2/2 * u*v);
matrix uMatU = funcUmatU(Vh, Vh);

varf funcVmatU(u,v) = int2d(Th)(dt * u*v);
matrix vMatU = funcVmatU(Vh, Vh);

varf funcUmatV(u,v) = - int2d(Th)(dt/2 * (dx(u)*dx(v) + dy(u)*dy(v)))
						- int1d(Th, 1)(dt/2 * u*v);;
matrix uMatV = funcUmatV(Vh, Vh);

varf funcM(u,v) = int2d(Th)(u*v);
matrix vMatV = funcM(Vh, Vh);

if (debug)
{
	{
		ofstream fout("uMatU.txt");
		fout << uMatU;
	}
	
	{
		ofstream fout("vMatU.txt");
		fout << vMatU;
	}
	
	{
		ofstream fout("uMatV.txt");
		fout << uMatV;
	}
	
	{
		ofstream fout("vMatV.txt");
		fout << vMatV;
	}
}

// ---

// setup initial values

Vh u, v;

u[] = u0[];
plot(u,wait=debug);

v[] = u1[];
plot(v,wait=debug);

// iterate according to Newmark

// TODO: How do we basic vector addition in FreeFem++?

real cpu = clock();

for (int i = 0; i < nSteps; i++)
{
	cout << "t: " << (1+i)*dt << "s" << endl;
	u[] = uMatU * u0[] ;//+ uMatV * v0[];
}

cout << "CPU time = " << clock()-cpu << endl;

/*

// save the solution for Gnuplot
{
	ofstream ff("graph.txt");
	for (int i=0;i<Th.nt;i++)
	{
		for (int j=0; j <3; j++)
		{
			ff<<Th[i][j].x << " "<< Th[i][j].y<< " "<<u[][Vh(i,j)]<<endl;
		}
		ff<<Th[i][0].x << " "<< Th[i][0].y<< " "<<u[][Vh(i,0)]<<"\n\n\n";
	}
}

}*/